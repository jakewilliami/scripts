#! /usr/bin/env bash

#IMPORTANT NOTE:
#There exists an alias in ~/.bashrc that looks like
#alias scripts="source mconfig"
#mconfig stands for mojave configuration, not macOS configuration.  I don't know why, but that is what I have decided, despite the repo name.

# define important directories
BASH_DIR="${HOME}/scripts/bash"
GIT_LOCATION="${HOME}/macOS-config/"

# define email for bitwarden
EMAIL="jakewilliami@icloud.com"

# get scripts for dependencies if I don't have them
if [[ ! -d "${HOME}"/scripts/ ]]
then
    cd "${HOME}" && \
    git clone https://github.com/jakewilliami/scripts.git
fi

# source required scripts
source ${BASH_DIR}/dependencies/source-dependencies.sh

# get kernel-specific dependencies
case $KERNEL in
    Darwin)
        is-library-then-install "${PYTHON3}" "${BITWARDEN_CLI}" "${GREP}"
        ;;
    Linux)
        is-library-then-install "${PYTHON3}" "${PIP3}"
        ;;
esac
# get os-specific dependencies
case $OS in
    debian)
        is-library-then-install "${SNAP}" && \
        sudo ln -s /var/lib/snapd/snap /snap && \
        sudo snap install bw
        ;;
    arch)
        aur_install "${NVM}" 'https://aur.archlinux.org/cgit/aur.git/snapshot/nvm.tar.gz'
        aur_install "${BITWARDEN_CLI}" 'https://aur.archlinux.org/cgit/aur.git/snapshot/bitwarden-cli.tar.gz'
        ;;
    fedora)
        is-library-then-install "${SNAP}" && \
        sudo ln -s /var/lib/snapd/snap /snap && \
        sudo snap install bw
        ;;
esac


# Help
display_help() {
    help_start 'curl-raw [option... | relative path to file...]' 'The present script will curl a raw file from my private macOS-config repo'
    help_commands '-l' '--listless' '1' 'Supresses' 'l' 'isting' 'directory contents.'
    help_help '2'
    clean-return
}


#get repo information
# if git rev-parse --is-inside-work-tree > /dev/null 2>&1
# then
#     REPO_NAME=$(basename $(git rev-parse --show-toplevel))
#     BRANCH=$(git rev-parse --abbrev-ref HEAD)
# else
    # echo -e "${BYELLOW}Setting repository name to standard 'macOS-config' and branch to standard 'master'.${NORM}"
    REPO_NAME='macOS-config'
    BRANCH='master'
# fi


pTouch() {
  for p do
    _dir="$(dirname -- "$p")"
    mkdir -p -- "$_dir" &&
      touch -- "$p"
  done
}


get_access_token() {
    # set booleans
    LOGIN=false
    # set counters
    LOGIN_TRY=0
    # make new current session
    bw --quiet logout
    # exit script if password is incorrect thrice
    while [[ ${LOGIN} == false ]]
    do
        if [[ "${LOGIN_TRY}" -lt "3" ]]
        then
            if [[ "${LOGIN_TRY}" -gt 0 ]]
            then
                echo -e "${BYELLOW}You have $((3-LOGIN_TRY)) attemps left.${NORM}"
            else
                echo -e "${BBLUE}===>${NORM}${BWHITE}\tRenewing BitWarden session and generating access token.  You have $((3-LOGIN_TRY)) attempts at logging into your BitWarden account.${NORM}"
            fi
            bw login --raw "${EMAIL}" > "${GIT_LOCATION}"/temp.d/bw-access-token && \
                LOGIN=true
            LOGIN_TRY=$((LOGIN_TRY+1))
        else
            echo -e "${BRED}Incorrect password.  Exiting.${NORM}"
            clean-exit
        fi
    done
    # sync vault
    echo -e "${BBLUE}===>${NORM}${BWHITE}\tSyncing vault.${NORM}"
    bw --quiet sync
    # generate gitlab bw id
    echo -e "${BBLUE}===>${NORM}${BWHITE}\tObtaining GitLab Access Token and project ID.${NORM}"
    bw list items --session $(cat "${GIT_LOCATION}/"temp.d/bw-access-token) --search GitLab | \
        jq --raw-output '.[] | .id' > \
        "${GIT_LOCATION}"/temp.d/gitlab-id
    # get access token from gitlab
    bw --session $(cat "${GIT_LOCATION}/"temp.d/bw-access-token) get item $(cat "${GIT_LOCATION}"/temp.d/gitlab-id) | \
        jq --raw-output '.fields | .[] | select(.name=="Personal Access Token for jakewilliami") | .value' > \
        "${GIT_LOCATION}/temp.d/gl-access-token"
    # get project id from gitlab
    bw --session $(cat "${GIT_LOCATION}/"temp.d/bw-access-token) get item $(cat "${GIT_LOCATION}"/temp.d/gitlab-id) | \
        jq --raw-output '.fields | .[] | select(.name=="Project ID for '$REPO_NAME'") | .value' > \
        "${GIT_LOCATION}/temp.d/gl-project-id"
}


INPUT_FILE="${1}"
process_input() {
    FULL_PATH=$(echo $(pwd)/${INPUT_FILE})
    INPUT_FILE_PROCESSED=$(echo "${INPUT_FILE}" | sed 's:/:%2F:g')
}


curl_raw() {
    if [[ -e "${FULL_PATH}" ]]
    then
        echo -e "${BYELLOW}===>${NORM}${ITYELLOW}\tOverwriting ${FULL_PATH} from repository.  Press control + C within five seconds to cancel.${NORM}" && \
        sleep 5
    else
        echo -e "${BBLUE}===>${NORM}${BWHITE}\tCreating ${FULL_PATH}.${NORM}" && \
        pTouch "${FULL_PATH}"
    fi
    if [ ! $(curl --raw --silent --show-error --write-out '%{http_code}' --header "PRIVATE-TOKEN: $(cat "${GIT_LOCATION}/temp.d/gl-access-token")" --url https://gitlab.com/api/v4/projects/$(cat "${GIT_LOCATION}/temp.d/gl-project-id")/repository/files/"${INPUT_FILE_PROCESSED}"/raw?ref="${BRANCH}" --output "${FULL_PATH}") == '404' ]
    then
        echo -e "${BGREEN}Output written to ${FULL_PATH}.${NORM}"
    else
        echo -e "${BRED}Could not find input file.  Removing file \`${FULL_PATH##*/}\` and any empty parents.${NORM}"
        rm "${FULL_PATH}"
        # clean up created file and empty parent directories
        COUNT_SEP="${FULL_PATH//[^\/]}"
        for countDir in $(seq 2 $((${#COUNT_SEP}+1)))
        do
            PARENT_DIR=$(echo ${FULL_PATH} | awk -v variable="${countDir}" -F/ '{ print $variable }')
            if [ -z "$(ls -A "${FULL_PATH%/${PARENT_DIR}*}/")" ]
            then
                rm -d "${FULL_PATH%/${PARENT_DIR}*}/"
            fi
        done
    fi
}


OPTIND=1
while getopts ":-:h" OPTION; do
        case $OPTION in
                -)
                    case $OPTARG in
                        help)
                            display_help ;;
                        *)
                            opt_err ;;
                    esac ;;
                h)
                    display_help ;;
                *)
                    opt_err ;;
        esac
done


if [[ $OPTIND -eq 1 ]]
then
    get_access_token
    process_input
    curl_raw
fi


# Clean up
clean-exit
