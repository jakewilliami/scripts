#! /bin/bash


# Check to see if homebrew is installed
if ! which -s brew
then
    echo -e "\u001b[1;33mInstalling dependencies...\u001b[0;38m" && \
    /usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)" && \
    echo -e "\u001b[1;38;5;2mHomebrew installed successfully\u001b[0;38m"
fi


# Ensure jq is installed
if ! brew ls --versions jq > /dev/null
then
    echo -e "\001b[1;38mInstalling \`jq\`...\u001b[0;38m" && \
    brew install jq && \
    echo -e "\u001b[1;38;5;2m\`jq\` installed successfully\u001b[0;38m"
fi


BASH_DIR="${HOME}/bin/scripts/bash/"


# Clean up
clean-exit() {
    [[ -f ${BASH_DIR}/textcolours.txt ]] && \
    rm ${HOME}/bin/scripts/bash/textcolours.txt
    exit $?
}


# Colours
jq -r 'to_entries|map("\(.key)=\(.value|tostring)")|.[]' ${BASH_DIR}/textcolours.json | sed -e 's/=\([^" >][^ >]*\)/="\1"/g' >> ${BASH_DIR}/textcolours.txt && source ${BASH_DIR}/textcolours.txt


display_help() {
    echo -e "${BWHITE}Usage: cd /dir/to/search/ && pdfsearch [\"search term(s)\"] [option...]${BWHITE}"
    echo
    echo -e "${ITWHITE}The present script will search PDFs in current directory and subdirectories for a search term, print the pdfs for which said term is found, and then print how many pdfs the search term was found in.  ${ITYELLOW}There is no current counter to tell how many times the search term was found.${NORM}"
    echo
    echo -e "${BBLUE}\t -h | --help \t${BYELLOW}Shows ${ULINE}${BBLUE}h${BYELLOW}elp${NORM}${BYELLOW} (present output).${NORM}"
    clean-exit
}


# Brew Install function
brew_install() {
    BREWINSTALL=false
    for i in ${@:2};
    do
        if ! brew ls --versions $i > /dev/null
        then
            BREWINSTALL=true
            echo ${1}
            brew install $i
        fi
    done
    if [ "${BREWINSTALL}" = true ]
    then
        return 0
    else
        return 1
    fi
}


# Satisfy Dependencies
brew_install "${BWHITE}Satisfying dependencies...${NORM}" coreutils pdfgrep && \
echo -e "${BGREEN}Dependencies satisfied.${NORM}"


opt_err() { #Invalid option (getopts already reported the illegal option)
    HELP="${BYELLOW}Not a valid option.  Use -h for help.${BNORM}"
    echo -e "${HELP}"
	clean-exit && clean-exit
}


while getopts ":-:h" OPTION; do
    case $OPTION in
        -)
            case $OPTARG in
                help)
                    display_help ;;
                *)
                    opt_err ;;
            esac ;;
        h)
            display_help ;; 
        *)
          opt_err ;;  
    esac
done

#start=$(python3 -c 'import time; print(time.time())')
start=`gdate +%s.%N` || clean-exit

#begin search
pdf_search=$(pdfgrep -ril $1) || clean-exit

echo -e "\033[1;38m${pdf_search}\033[0;38m"

#end of search

#calculates runtime (because *nix on os x is bad and doesn't support %N)
#end=$(python3 -c 'import time; print(time.time())')
end=`gdate +%s.%N`

runtime=$(echo "$end - $start" | bc )
pdf_count=$(pdfgrep -ril $1 | wc -l)

echo -e "\033[1;33m$runtime seconds\033[0;38m"

echo -e "\033[1;38;5;2mThe word \"$1\" was found in"${pdf_count}" PDFs\033[0;38m"


#Other meand of calculating runtime:

#python3 -c 'import time; print("%s seconds" % round(time.time()/10000000000, 2))'
#ruby -e 'puts Time.now.to_f/10000000000'#Output in seconds
#php -r 'echo microtime(TRUE)/10000000000;' 
#| perl -MTime::Piece -pe 's/(\d{13})/Time::Piece->localtime($1 \/1000)->strftime("%Y-%m-%d %a")/e'


clean-exit
