#! /bin/bash

# define bash directory
BASH_DIR="${HOME}/scripts/bash/"

# source required scripts
source ${BASH_DIR}/dependencies/source-dependencies.sh

# get script dependencies
is-command-then-install "${DHCPING}"
[[ $OS == "debian" ]] && is-command-then-install "${TSHARK}" "${ROOTKITHUNT}"
[[ ! $OS == "debian" ]] && is-command-then-install "${SNIFF}" "${NMAP}"
is-library-then-install "${DHCP}" "${ARPSCAN}"

# Help
display_help() {
    help_start 'local-net [option...]' 'The present script will ping local machines using different tools (see options).'
    help_commands '-a' '--arp' '2' 'Prints' 'a' 'rp' 'results.'
    help_commands '-A' '--alternate-sniff' '1' '\b' 'S' 'niff' '\bs using alternate method.  See also options `-s` and `-S`.'
    help_commands '-g' '--geo-location' '1' 'Shows' 'g' 'eo-location' 'information based on one\x27s (public) IP address.'
    help_commands '-H' '--Hostnames' '1' '[OPTION IN DEVELOPMENT] Finds' 'H' 'ostnames' 'within the local network.'
    help_commands '-l' '--local' '2' 'Returns' 'l' 'ocal' 'IP address of present computer.'
    help_commands '-m' '--malware' '2' 'Check the present computer for' 'm' 'alware' '(in the form of rootkits).'
    help_commands '-M' '--minimal-arp' '1' 'Prints a' 'M' 'inimal arp' 'output.'
    help_commands '-n' '--nmap' '2' 'Prints' 'n' 'map' 'results.'
    help_commands '-p' '--ping' '2' 'Prints' 'p' 'ing' '\bed results.'
    help_commands '-P' '--Public' '2' 'Returns' 'P' 'ublic' 'IP address of the present local network.'
    help_commands '-q' '--query-server' '1' '\b' 'Q' 'uery server' '\bs on the local network.'
    help_commands '-s' '--sniff' '2' '\b' 'S' 'niff' '\bs packages exchanged through the local network.'
    help_commands '-S' '--verbose-sniff' '1' '\b' 'V' 'erbosely sniff' '\bs packages exchanged through the local network.'
    help_help '2'
    clean-exit
}


# Get public IP
PUBLIC_IP=$(curl ipinfo.io/ip)
# set wireless interfaces to save script time when needing to check
HOSTNAME=$(hostname)
if [[ ${HOSTNAME%%.*} == 'jake-imac2008' ]]
then
    WIRELESS_DEVICE='wls4'
elif [[ ${HOSTNAME%%.*} == 'jake-macbook2007' ]]
then
    WIRELESS_DEVICE='eth0'
elif [[ ${HOSTNAME%%.*} == 'jake-mbp2017' ]]
then
    WIRELESS_DEVICE='en0'
fi



ping_function() {
    for i in $(seq 1 254); do
        (ping -c 1 192.168.1.$i | grep "bytes from" &) #& at end makes it run parallel
    done
    sleep 1
}


rootkits() {
    if [[ $KERNEL == "Darwin" || $OS == "arch" ]]
    then
        echo -e "${BYELLOW}This option is not currently supported for macOS or Arch.${NORM}"
    else
        sudo rkhunter --check
    fi
}


query_server() {
    sudo dhcping -s 192.168.1.1 #ask this separately to avoid getting asked for password 254 times
    for i in $(seq 2 254); do
        (sudo dhcping -s 192.168.1.${i} > /dev/null 2>&1 && echo "Response from 192.168.1.${i}" &)
    done 
}


arp_function() {
    sudo arp-scan -l   
}



sniff_alternative() {
    if [[ $OS == "debian" ]]
    then
        sudo tshark
    else
        echo -e "${BYELLOW}This option is not currently supported for macOS or Arch.${NORM}"
    fi
}


nmap_function() {
#    IP=`ifconfig  | grep 'inet addr:'| grep -v '127.0.0.1' | cut -d: -f2 | awk '{ print $1}'`
    if [[ $OS == "debian" ]]
    then
        echo -e "${BYELLOW}This option is not currently supported for Debian.${NORM}"
    else
        SUBNET=$(echo `ifconfig  | grep 'Mask:'| grep -v '127.0.0.1' | cut -d: -f4 | awk '{print $1}' | grep -o 255 | wc -l`*8 | bc)
        #fping -a -g $IP/$SUBNET
        nmap -sP $IP/$SUBNET
    fi
}


sniff_function() {
    if [[ $OS == "debian" ]]
    then
        echo -e "${BYELLOW}This option is not currently supported for Debian.${NORM}"
    else
        sudo sniffglue -vv "${WIRELESS_DEVICE}"
    fi
}


verbose_sniff() {
    if [[ ${KERNEL} == "Linux" ]]
    then
        sudo netsniff-ng
    else
        sudo sniffglue -vvvv "${WIRELESS_DEVICE}"
    fi
}


dhcp_function() {
    sudo dhcpdump -i "${WIRELESS_DEVICE}" | grep -B2 'Host name'
}


local_ip() {
    if [[ $KERNEL == "Darwin" ]]
    then
        #DEVICE="echo ${WIRELESS_DEVICE}"
        #LOCAL_IP=$(ipconfig getifaddr $(eval "${DEVICE}"))
        LOCAL_IP="$(ipconfig getifaddr en0)"
        [[ -z "${LOCAL_IP}" ]] && LOCAL_IP="$(ipconfig getifaddr en1)"
    elif [[ $KERNEL == "Linux" ]]
    then
        #ifconfig | sed -En 's/127.0.0.1//;s/.*inet (addr:)?(([0-9]*\.){3}[0-9]*).*/\2/p'
        LOCAL_IP=$(ip route get 1 | awk -F'src' '{print $2; exit}')
        LOCAL_IP=${LOCAL_IP/uid*}
        [[ -z "${LOCAL_IP}" ]] && LOCAL_IP="$(/sbin/ifconfig -a | awk '/broadcast/ {print $2; exit}')"
    fi
    echo "${LOCAL_IP}"
}


public_ip() {
    echo "${PUBLIC_IP}"
}


ip_specs() {
    output_type="${1}"  # Can interpret json, xml, and csv
    curl -s "https://freegeoip.app/${output_type}/${2}" | jq .
}


geo_ip_public() {
    myip=$(curl -s ipinfo.io/ip | sed 's/[a-zA-Z<>/ :]//g')  # Get ip address
    ip_specs "json" "${myip}"
}


minimal_arp() {
    arp -a
}


# Options
while getopts ":-:aMnphlHPsSgVmqA" OPTION; do
        case $OPTION in
                -)
                    case $OPTARG in
                        malware)
                            rootkits
                            clean-exit ;;
                        query-server)
                            query_server
                            clean-exit ;;
                        arp)
                            arp_function
                            clean-exit ;;
                        minimal-arp)
                            minimal_arp
                            clean-exit ;;
                        nmap)
                            nmap_function
                            clean-exit ;;
                        ping)
                            ping_function
                            clean-exit ;;
                        sniff)
                            sniff_function
                            clean-exit ;;
                        verbose-sniff)
                            verbose_sniff
                            clean-exit ;;
                        alternate-sniff)
                            sniff_alternative
                            clean-exit ;;
                        Hostnames)
                            dhcp_function
                            clean-exit ;;
                        local)
                            local_ip
                            clean-exit ;;
                        Public)
                            public_ip
                            clean-exit ;;
                        geo-location)
                            geo_ip_public
                            clean-exit ;;
                        help)
                            display_help ;;
                        *)
                            opt_err ;;
                    esac ;;
                m)
                    rootkits
                    clean-exit ;;
                M)
                    minimal_arp
                    clean-exit ;;
                q)
                    query_server
                    clean-exit ;;
                a)
                    arp_function 
                    clean-exit ;;
                A)
                    sniff_alternative
                    clean-exit ;;
                n)
                    nmap_function
                    clean-exit ;;
                p)
                    ping_function
                    clean-exit ;;
                s)
                    sniff_function
                    clean-exit ;;
                S)
                    verbose_sniff
                    clean-exit ;;
                H)
                    dhcp_function
                    clean-exit ;;
                l)
                    local_ip
                    clean-exit ;;
                P)
                    public_ip
                    clean-exit ;;
                g)
                    geo_ip_public
                    clean-exit ;;
                h)
                    display_help ;;
                *)
                    opt_err ;;
        esac
done


# If no options
[[ -z $1 ]] && echo -e "${BYELLOW}Please specify an option.  Use option -h for help.${NORM}"


# Clean up
clean-exit