use std::collections::HashMap;

// main function!
fn main() {
	let mut list: [isize; 7] = [2, 3, 3, 2, 4, 5, 4];
	let most_frequent: isize = find_most_frequent_integer_hashmap(&list);
	let most_frequent_alt: isize = find_most_frequent_integer_manual(&list);
    println!("The most common integer in the list {:?} generated by the hashmap method is {}", list, most_frequent);
	println!("The most common integer in the same list generated by the slow, bad method is {}", most_frequent_alt);
}

// Method: hashmap solution
fn find_most_frequent_integer_hashmap(values: &[isize]) -> isize {	
	let mut counter: isize = 0;
	let mut most_frequent: isize = 0;
	let mut countmap = HashMap::<isize, isize>::new();

	// map.insert(j, k.to_owned());
	for i in values.iter() {
		let current_count_temp = countmap.get(&i);
		// let mut current_count: isize = *countmap.get(&i).unwrap();
		let mut current_count: isize = 0;
		if current_count_temp != None {
			current_count = *current_count_temp.unwrap();
			// println!("New count of {} is {}", i, current_count + 1);
		// } else {println!("Initialised counter for {}", i)}
		}

		current_count += 1;
		// println!("Current count for {} is {}", i, current_count);
		countmap.insert(*i, current_count);
		let new_count_val: &isize = countmap.get(&i).unwrap();
		
		if new_count_val >= &counter {
			counter = *new_count_val;
			// println!("The count of {} is greater than or equal to that of the current counter", i);
			// println!("Now checking current element {} against current most frequent {}", i, most_frequent);
			if i < &most_frequent || most_frequent == 0 {	
				// println!("Most frequent is now {}", i);
				most_frequent = *i;
			}
		}
	}

	return most_frequent;
}

// Method: non-hashmap solution
fn find_most_frequent_integer_manual(values: &[isize]) -> isize {
	/*
	// sort the input array
	for (i, _) in values.iter().enumerate() {
		// for (j, e2) in values.iter().enumerate {
		let mut j: usize = 0;
		while j < (values.len() - i - 1) {
			// swap if current element is greater than next
			if values[j] > values[j + 1] {
				let t: isize = values[j];
				values[j] = values[j + 1];
				values[j + 1] = t;
			} // end if
			// increment inner index counter
			j += 1;
		} // end while
		// } // end for (j, e2)...
	} // end for (i, e)...
	
	// reverse the sorted array
	*/
	
	let input_arr_length: usize = values.len();
	// let mut counts: [isize; 7] = [];
	// let mut counts = Vec::new();
	let mut counts = vec![0; input_arr_length];
	
	for (i, e) in values.iter().enumerate() {
		let mut count: isize = 0;
		
		for _ in values.iter() {
			if *e == values[i] {// or i?
				count += 1
			} // end if

			// to counts list
			counts[i] = count;// or is it i?
			// counts.Vec::insert(count);
		} // end for j...
	} // end for (i, e)...

	// get max value from list of counts 
	let mut maxcount: isize = isize::MIN;
	for e in counts.iter() {
		if e > &maxcount {
			maxcount = *e;
		} // end if
	} // end for e...	

	// find the element whose count is maximal
	for (i, _) in values.iter().enumerate() {
		if counts[i] == maxcount {
			return values[i];
		} // end if
	} // end for (i, _)...

	return 0; // something went wrong
}

// putting a `Default` bound on the generic `T` means we can use its default value to initialise `most_frequent`
/*
fn find_most_frequent_integer_hashmap<T: Default>(values: &[T]) -> T {
	let mut counter: isize = 0;
	let mut most_frequent: T = T::default();	
	let mut countmap = HashMap::<T, isize>::new();

	// map.insert(j, k.to_owned());
	for (i, e) in values.iter().enumerate() {
		let mut current_count: isize = countmap.get(&e).map_or(0);
		current_count += 1;
		countmap.insert(e, current_count);
		
		if countmap.get(&e).unwrap() >= counter {
			counter = countmap.get(&e);
			most_frequent = e;
		}
	}

	return most_frequent;
}
*/
