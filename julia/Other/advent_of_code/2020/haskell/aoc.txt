-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/

@package aoc


-- | AOC is a library of useful functions for solving coding problems.
--   
--   It accompanies a <a>video series</a> describing how to solve the
--   <a>2020 Advent of Code challenges</a>. It is intended as a learning
--   tool for beginner and intermediate Haskellers, so often goes into some
--   depth describing Haskell concepts, tools, and library functions.
--   
--   The code for this module along with the 2020 AoC solutions can be
--   cloned from <a>GitHub</a>.
module AOC

-- | The <a>interact</a> function replaces <a>interact</a>. It reads from
--   stdin and splits the input into <a>lines</a>. It uses the given
--   function to turn the resulting list of <a>String</a>s into a
--   <a>Show</a>able value. It <a>show</a>s the value and sends it to
--   stdout with an added newline.
--   
--   <pre>
--   &gt;&gt;&gt; sumValuesProg = interact (sum . map read)
--   </pre>
interact :: Show a => ([String] -> a) -> IO ()

-- | The <a>interact'</a> function reads from stdin and uses the given
--   function to run the resulting <a>String</a> into a <a>Show</a>able
--   value. It <a>show</a>s the value and sends it to stdout with an added
--   newline.
--   
--   <pre>
--   &gt;&gt;&gt; fileSizeProg = interact' length
--   </pre>
interact' :: Show a => (String -> a) -> IO ()

-- | The <a>interactg</a> function will not only split by <a>lines</a>,
--   like <a>interact</a>, but also splits these into groups separated by
--   blank lines. Therefore, the given function must accept a list of list
--   of <a>String</a>s.
--   
--   <pre>
--   &gt;&gt;&gt; countParagraphsProg = interactg length
--   </pre>
interactg :: Show a => ([[String]] -> a) -> IO ()

-- | <a>Parser</a> is a convenience type for <a>Parsec</a>
type Parser = Parsec String ()

-- | The <a>parse</a> function is a convenience function for <a>parse</a>
--   that removes the requirement to provide a file name.
parse :: Parser a -> String -> Either ParseError a

-- | The <a>parselist</a> function parses a list of <a>String</a>s using
--   <a>parse</a> and returns the list of parsed "a"s. If any parse was
--   unsuccessful we crash the program, showing the first error
--   encountered.
parselist :: Parser a -> [String] -> [a]

-- | The <a>chari</a> function is a case-insensitive <a>Parser</a> for the
--   given <a>Char</a>. It uses <a>toLower</a> and <a>toUpper</a> on the
--   given <a>Char</a> to test the input with.
--   
--   <pre>
--   &gt;&gt;&gt; parse (chari 'e') "E"
--   Right 'E'
--   </pre>
chari :: Char -> Parser Char

-- | The <a>stringi</a> function is a case-insensitive <a>Parser</a> for
--   the given <a>String</a>.
--   
--   <pre>
--   &gt;&gt;&gt; parse (stringi "HeLlO") "Hello world!"
--   Right "Hello"
--   </pre>
stringi :: String -> Parser String

-- | The <a>enump</a> function is a case-insensitive <a>Parser</a> for any
--   <a>Bounded</a> <a>Enum</a>.
--   
--   <pre>
--   &gt;&gt;&gt; data Primary = Red | Green | Blue deriving (Show, Enum, Bounded)
--   
--   &gt;&gt;&gt; parselist enump $ words "red green red blue" :: [Primary]
--   [Red,Green,Red,Blue]
--   </pre>
enump :: forall b. (Enum b, Bounded b, Show b) => Parser b

-- | The 'integer function is a <a>Parser</a> for unsigned <a>Int</a>s.
--   
--   <pre>
--   &gt;&gt;&gt; parse integer "301"
--   Right 301
--   </pre>
integer :: Parser Int

-- | The <a>readBin</a> function reads a binary number from a String. Any
--   non-binary digit encountered will result in a Nothing.
--   
--   <pre>
--   &gt;&gt;&gt; readBin "01011010"
--   Just 90
--   </pre>
readBin :: ReadBin a => [a] -> Maybe Int

-- | A newtype for String whose show implementation doesn't add quotes.
--   
--   <pre>
--   &gt;&gt;&gt; Str "abc"
--   abc
--   </pre>
newtype Str
Str :: String -> Str

-- | The <a>count</a> function returns the number of occurrences of the
--   given value in the given list.
--   
--   <pre>
--   &gt;&gt;&gt; count 'e' "Advent of Code 2020"
--   2
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; count 2 [3,2,1,0,4,2,3,4,2]
--   3
--   </pre>
count :: Eq a => a -> [a] -> Int

-- | The <a>tr</a> function translates lists according to a given mapping.
--   
--   <pre>
--   &gt;&gt;&gt; tr "LR" "01" "LALR"
--   "0A01"
--   </pre>
tr :: Ord a => [a] -> [a] -> [a] -> [a]

-- | The <a>!|</a> operator indexes into a <a>Vector</a> modulo its length.
--   This will crash with a <a>DivideByZero</a> <a>ArithException</a> if
--   the <a>Vector</a> is empty. O(1)
--   
--   <pre>
--   &gt;&gt;&gt; ltov [0..99] !| 254375
--   75
--   </pre>
(!|) :: Vector a -> Int -> a

-- | The <a>ltov</a> function is a convenience function for
--   <a>fromList</a>.
ltov :: [a] -> Vector a

-- | The <a>ltov2</a> function converts a list of lists into a
--   <a>Vector</a> of <a>Vector</a>s.
ltov2 :: [[a]] -> Vector (Vector a)

-- | The <a>ltov3</a> function converts a list of lists of lists into a
--   <a>Vector</a> of <a>Vector</a>s of <a>Vector</a>s.
ltov3 :: [[[a]]] -> Vector (Vector (Vector a))

-- | The <a>ltov4</a> function converts a list of lists of lists of lists
--   into a <a>Vector</a> of <a>Vector</a>s of <a>Vector</a>s of
--   <a>Vector</a>s.
ltov4 :: [[[[a]]]] -> Vector (Vector (Vector (Vector a)))

-- | The <a>vtol</a> function is a convenience function for <a>toList</a>.
vtol :: Vector a -> [a]

-- | The <a>vtol2</a> function converts a <a>Vector</a> of <a>Vector</a>s
--   into a list of lists.
vtol2 :: Vector (Vector a) -> [[a]]

-- | The <a>vtol2</a> function converts a <a>Vector</a> of <a>Vector</a>s
--   of <a>Vector</a>s into a list of lists of lists.
vtol3 :: Vector (Vector (Vector a)) -> [[[a]]]

-- | The <a>vtol2</a> function converts a <a>Vector</a> of <a>Vector</a>s
--   of <a>Vector</a>s of <a>Vector</a>s into a list of lists of lists of
--   lists.
vtol4 :: Vector (Vector (Vector (Vector a))) -> [[[[a]]]]

-- | The <a>summarize</a> function does a bottom-up calculation on a
--   directed acyclic graph (DAG) by running a summary function on each
--   node.
--   
--   <pre>
--   &gt;&gt;&gt; f [] = 1; f xs = sum $ map snd xs
--   
--   &gt;&gt;&gt; summarize ([1..10], \x -&gt; [(0, y) | y &lt;- [2*x, 3*x..10]]) f 1
--   13
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; f [] = 1; f xs = sum $ map (\(w, s) -&gt; w * s) xs
--   
--   &gt;&gt;&gt; summarize ([1..10], \x -&gt; [(y, y) | y &lt;- [2*x, 3*x..10]]) f 1
--   279
--   </pre>
summarize :: Ord n => ([n], n -> [(v, n)]) -> ([(v, w)] -> w) -> n -> w

-- | Replaces the <a>nub</a> function from Data.List with a faster version
--   that also sorts the list.
nub :: Ord a => [a] -> [a]

-- | The <a>map2</a> function is simply <a>fmap</a> <a>.</a> <a>fmap</a>.
map2 :: (Functor f, Functor g) => (a -> b) -> f (g a) -> f (g b)

-- | The <a>converge</a> function repeatedly applies f until there's no
--   change in the output. That is, it calculates &lt;math&gt;.
converge :: Eq a => (a -> a) -> a -> a

-- | The <a>applyN</a> function applies f n times.
--   
--   <pre>
--   &gt;&gt;&gt; applyN 5 (+2) 3
--   13
--   </pre>
applyN :: Int -> (b -> b) -> b -> b

-- | The <a>mapnbs</a> function maps a function over a <tt>List</tt> of
--   <tt>List</tt>s, treating it as a grid of cells. Given a list of
--   coordinate offsets, the mapping function is provided the cell value,
--   and a list of the values of the cells at those offsets.
--   
--   <pre>
--   &gt;&gt;&gt; mapnbs nbs8 conwayRule False $ replicate 5 $ replicate 5 True
--   [[False,False,True,True,True,False,False],[False,True,False,False,False,True,False],[True,False,False,False,False,False,True],[True,False,False,False,False,False,True],[True,False,False,False,False,False,True],[False,True,False,False,False,True,False],[False,False,True,True,True,False,False]]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; mapnbs nbs4 conwayRule False $ replicate 5 $ replicate 5 True
--   [[True,True,True,True,True],[True,False,False,False,True],[True,False,False,False,True],[True,False,False,False,True],[True,True,True,True,True]]
--   </pre>
mapnbs :: Eq a => [(Int, Int)] -> (a -> [a] -> a) -> a -> [[a]] -> [[a]]

-- | The <a>mapnbs3</a> function is the 3-d variant of <a>mapnbs</a>.
mapnbs3 :: Eq a => [(Int, Int, Int)] -> (a -> [a] -> a) -> a -> [[[a]]] -> [[[a]]]

-- | The <a>mapnbs4</a> function is the 4-d variant of <a>mapnbs</a>.
mapnbs4 :: Eq a => [(Int, Int, Int, Int)] -> (a -> [a] -> a) -> a -> [[[[a]]]] -> [[[[a]]]]

-- | The <a>maplos</a> function maps a function over a <a>Vector</a> of
--   <a>Vector</a>s, treating it as a grid of cells. A coordinate list is
--   supplied and the given predicate determines what is considered an
--   empty cell. The mapping function is provided the cell value, and a
--   list of cell values that are in the line of sight, in the direction of
--   the given coordinates.
--   
--   <pre>
--   &gt;&gt;&gt; maplos nbs8 not conwayRule $ ltov2 $ replicate 5 $ replicate 5 True
--   [[True,False,False,False,True],[False,False,False,False,False],[False,False,False,False,False],[False,False,False,False,False],[True,False,False,False,True]]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; maplos nbs4 not conwayRule $ ltov2 $ replicate 5 $ replicate 5 True
--   [[True,True,True,True,True],[True,False,False,False,True],[True,False,False,False,True],[True,False,False,False,True],[True,True,True,True,True]]
--   </pre>
maplos :: [(Int, Int)] -> (a -> Bool) -> (a -> [a] -> b) -> Vector (Vector a) -> Vector (Vector b)

-- | <a>nbs4</a> lists the offsets of the four non-diagonal neighbours of a
--   cell in a grid.
nbs4 :: [(Int, Int)]

-- | <a>nbs8</a> lists the offsets of the eight neighbours of a cell in a
--   grid.
nbs8 :: [(Int, Int)]

-- | 3-d equivalent of <a>nbs4</a>
nbs6 :: [(Int, Int, Int)]

-- | 3-d equivalent of <a>nbs8</a>
nbs26 :: [(Int, Int, Int)]

-- | 3-d equivalent of <a>nbs4</a>
nbs8_4 :: [(Int, Int, Int, Int)]

-- | 3-d equivalent of <a>nbs8</a>
nbs80 :: [(Int, Int, Int, Int)]

-- | The <a>conwayRule</a> function is an implementation of the rule
--   followed by the cells in Conway's Game of Life. It can be used with
--   the <tt>map8nbs</tt> function to model the original version of the
--   game.
--   
--   <pre>
--   &gt;&gt;&gt; conwayRule True [True, False, True, False, True, True, False, False]
--   False
--   </pre>
conwayRule :: Bool -> [Bool] -> Bool

-- | <a>*$</a> provides scalar multiplication of a 2-tuple.
--   
--   <pre>
--   &gt;&gt;&gt; 2 *$ (1, 4)
--   (2,8)
--   </pre>
(*$) :: Int -> (Int, Int) -> (Int, Int)

-- | The <a>dir</a> function converts a cardinal direction (e.g. 'E') into
--   a unit coordinate.
--   
--   <pre>
--   &gt;&gt;&gt; dir 'E'
--   (1,0)
--   </pre>
dir :: (Num a, Num b) => Char -> (a, b)

-- | The <a>rot</a> function rotates an (x, y) coordinate 90 degrees.
--   
--   <pre>
--   &gt;&gt;&gt; rot (-3, 4)
--   (-4,-3)
--   </pre>
rot :: Num a => (b, a) -> (a, b)

-- | The <a>rotn</a> function rotates an (x, y) coordinate through n
--   90-degree turns.
--   
--   <pre>
--   &gt;&gt;&gt; rotn 2 (-3, 4)
--   (3,-4)
--   </pre>
rotn :: forall t b. (Num b, Integral t) => t -> (b, b) -> (b, b)

-- | The <a>manhattan</a> function provides a 2-tuple's Manhattan distance
--   from the origin.
--   
--   <pre>
--   &gt;&gt;&gt; manhattan (-3, 4)
--   7
--   </pre>
manhattan :: Num a => (a, a) -> a
instance Data.Bits.Bits AOC.Bin
instance GHC.Num.Num AOC.Bin
instance GHC.Enum.Bounded AOC.Bin
instance GHC.Enum.Enum AOC.Bin
instance GHC.Classes.Ord AOC.Bin
instance GHC.Classes.Eq AOC.Bin
instance GHC.Read.Read AOC.Str
instance GHC.Classes.Ord AOC.Str
instance GHC.Classes.Eq AOC.Str
instance GHC.Show.Show AOC.Str
instance GHC.Show.Show AOC.Bin
instance GHC.Read.Read AOC.Bin
instance AOC.ReadBin GHC.Types.Char
instance AOC.ReadBin GHC.Types.Bool
instance (GHC.Num.Num a, GHC.Num.Num b) => GHC.Num.Num (a, b)
instance (GHC.Num.Num a, GHC.Num.Num b, GHC.Num.Num c) => GHC.Num.Num (a, b, c)
instance (GHC.Num.Num a, GHC.Num.Num b, GHC.Num.Num c, GHC.Num.Num d) => GHC.Num.Num (a, b, c, d)
